#!/usr/bin/env python3
# Generated by usbrply
# cmd: /Library/Frameworks/Python.framework/Versions/3.10/bin/usbrply

import binascii
import time
import usb1
import time


def validate_read(expected, actual, msg):
    if expected != actual:
        print('Failed %s' % msg)
        print('  Expected; %s' % binascii.hexlify(expected,))
        print('  Actual:   %s' % binascii.hexlify(actual,))
        #raise Exception("failed validate: %s" % msg)

def hex_string_to_formatted_binary_array(hex_string):
    return bytes.fromhex(hex_string)


def interruptRead(dev, endpoint, size, timeout=None):
    return dev.interruptRead(endpoint, size,
                timeout=(1000 if timeout is None else timeout))

def interruptWrite(dev, endpoint, data, timeout=None):
    #print(data)
    dev.interruptWrite(endpoint, data, timeout=(1000 if timeout is
None else timeout))

def create_byte_array_for_rot(rotation):
  """
  Creates a byte array with the specified rotation.

  Args:
    rotation: The rotation value.

  Returns:
    A byte array.
  """
  low_byte = rotation & 0xFF
  high_byte = (rotation >> 8) & 0xFF
  return bytearray([0x6b, low_byte, high_byte, 0x0d, low_byte, high_byte, 0x00, 0x00])



def rotate_to_angle(dev, angle):


    # Generated by usbrply
    # Source: Windows pcap (USBPcap)
    # cmd: /Library/Frameworks/Python.framework/Versions/3.10/bin/usbrply

    # PCapGen device hi: selected device 2
    # Generated from packet 7/8

    iangle = int(angle * 29)


    interruptWrite(dev, 0x02, hex_string_to_formatted_binary_array("672474038fb02795"))
    result = interruptRead(dev, 0x81, 8)
    print(result.hex())
    rot_array = create_byte_array_for_rot(iangle)
    print(rot_array.hex())
    interruptWrite(dev, 0x02,rot_array)



    for i in range(10):
        interruptWrite(dev, 0x02, hex_string_to_formatted_binary_array("6875f90538db760b"))
        result = interruptRead(dev, 0x81, 8)
        print(result.hex())
        time.sleep(0.01)

def c2_byte(v):
    if (v < 0):
        return 0x80 - v
    return v


def create_byte_array_for_move(dx, dy):
  """
  Creates a byte array with the specified rotation.

  Args:
    rotation: The rotation value.

  Returns:
    A byte array.
  """
  return bytearray([0x32, c2_byte(dx), c2_byte(dy), 0x00, 0x81, 0x7a, 0x90, 0x90])




def move_ao(dev, dx, dy):
    mov_array = create_byte_array_for_move(dx, dy)
    #print(mov_array.hex())
    interruptWrite(dev, 0x02,mov_array)



def build_motor_move_array(motor_idx, delta):
  return bytearray([0x61, c2_byte(delta), c2_byte(motor_idx), 0x00, 0xc7, 0xdd, 0x42, 0x1a])



def move_motors(dev, m1, m2, m3, m4):
    mov_1 = build_motor_move_array(0, m1)
    mov_2 = build_motor_move_array(1, m2)
    mov_3 = build_motor_move_array(2, m3)
    mov_4 = build_motor_move_array(3, m4)
    print((mov_1.hex()))
    print((mov_2.hex()))
    print((mov_3.hex()))
    print((mov_4.hex()))

    interruptWrite(dev, 0x02,mov_1)
    time.sleep(0.03)
    interruptWrite(dev, 0x02,mov_2)
    time.sleep(0.03)
    interruptWrite(dev, 0x02,mov_3)
    time.sleep(0.03)
    interruptWrite(dev, 0x02,mov_4)
    time.sleep(0.03)


def b_2_i(v):
    if (v > 128):
        return v - 256
    return v

def get_ao_pos(dev):
    
    interruptWrite(dev, 0x02, hex_string_to_formatted_binary_array("30000000c7dd421a"))
    interruptWrite(dev, 0x02, hex_string_to_formatted_binary_array("3916421ac7dd421a"))
    interruptWrite(dev, 0x02, hex_string_to_formatted_binary_array("62000000c7dd421a"))

    
    result = interruptRead(dev, 0x81, 8)
    print(b_2_i(result[0]), b_2_i(result[1]), b_2_i(result[2]), b_2_i(result[3]))
    return b_2_i(result[0]), b_2_i(result[1]), b_2_i(result[2]), b_2_i(result[3])

def open_dev(vid_want, pid_want, usbcontext=None):
    if usbcontext is None:
        usbcontext = usb1.USBContext()

    print("Scanning for devices...")
    for udev in usbcontext.getDeviceList(skip_on_error=True):
        vid = udev.getVendorID()
        pid = udev.getProductID()
        if (vid, pid) == (vid_want, pid_want):
            print("Found device")
            print("Bus %03i Device %03i: ID %04x:%04x" % (
                udev.getBusNumber(),
                udev.getDeviceAddress(),
                vid,
                pid))
            return udev.open()
    raise Exception("could not connect to AO unit")


def get_homing_status(dev):
    #interruptWrite(dev, 0x02, hex_string_to_formatted_binary_array("63000000c7dd421a"))
    #interruptWrite(dev, 0x02, hex_string_to_formatted_binary_array("36050000c7dd421a"))
    interruptWrite(dev, 0x02, hex_string_to_formatted_binary_array("34000000c7dd421a"))
    result = interruptRead(dev, 0x81, 8)
    return result[0]

def home1(dev):
    for k in range(6):
        move_motors(dev, -20, 0, 0, 0)
        print(hex(get_homing_status(dev)))

    move_motors(dev, 100, 0, 0, 0)

    for k in range(6):
        move_motors(dev, 0, -20, 0, 0)
        print(hex(get_homing_status(dev)))

    move_motors(dev, 0, 100, 0, 0)

    for k in range(6):
        move_motors(dev, 0, 0, -20, 0)
        print(hex(get_homing_status(dev)))

    move_motors(dev, 0, 0, 100, 0)


    for k in range(6):
        move_motors(dev, 0, 0, 0, -20)
        print(hex(get_homing_status(dev)))

    move_motors(dev, 0, 0, 0, 100)
    print(hex(get_homing_status(dev)))

def home(dev):
    m1, m2, m3, m4 = get_ao_pos(dev)
    #print("initial pos = ", m1, m2, m3, m4)
    move_motors(dev, m1, m2, m3, m4)
    time.sleep(0.2)
    m1, m2, m3, m4 = get_ao_pos(dev)
    #print("initial pos = ", m1, m2, m3, m4)
    status = get_homing_status(dev)

    while(status != 0):
        print(hex(status))
        #m1, m2, m3, m4 = get_ao_pos(dev)
        #print("new pos = ", m1, m2, m3, m4)
        if (status & 0x80 != 0):
            move_m4 = -7
        else:
            move_m4 = 2

        if (status & 0x40 != 0):
            move_m3 = -7
        else:
            move_m3 = 2

        if (status & 0x20 != 0):
            move_m2 = -7
        else:
            move_m2 = 2

        if (status & 0x10 != 0):
            move_m1 = -7
        else:
            move_m1 = 2

        #print("new move is ", move_m1, move_m2, move_m3, move_m4)
        move_motors(dev, move_m1, move_m2, move_m3, move_m4)

        status = get_homing_status(dev)


    m1, m2, m3, m4 = get_ao_pos(dev)
    print("initial pos = ", m1, m2, m3, m4)
    move_motors(dev, m1, m2, m3, m4)
    time.sleep(1)
    m1, m2, m3, m4 = get_ao_pos(dev)
    print("initial pos = ", m1, m2, m3, m4)

    return status

def main():
    import argparse

    vid_want = 0x03EB
    pid_want = 0x2013

    usbcontext = usb1.USBContext()
    dev = open_dev(vid_want, pid_want, usbcontext)
    
    dev.resetDevice()

    try:
        dev.detachKernelDriver(0)
    except:
        print("already detached")

    dev.claimInterface(0)
    move_ao(dev, -120, 120)
    home(dev)
    #rotate_to_angle(dev, 90)

    #get_ao_pos(dev)
    #move_motors(dev, 60, 0, 0, 0)
    #move_motors(dev, 60, 0, 0, 0)
    #move_motors(dev, 20, 0, 0, 0)
    #move_motors(dev, -80, 0, 0, 0)


    get_ao_pos(dev)



"""
    move_ao(dev, 120, 120)
    time.sleep(0.3)
    move_ao(dev, 120, 120)
    time.sleep(0.3)
    move_ao(dev, -127, -127)
    time.sleep(0.3)
    for i in range(200):
        #move_ao(dev, 32, 0)
        time.sleep(0.3)
        move_ao(dev, 0, 32)
        time.sleep(0.3)
        #move_ao(dev, -32, 0)
        time.sleep(0.3)
        move_ao(dev, -0, -32)

        get_ao_pos(dev)
"""

if __name__ == "__main__":
    main()