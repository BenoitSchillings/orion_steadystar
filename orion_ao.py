#!/usr/bin/env python3
# Generated by usbrply
# cmd: /Library/Frameworks/Python.framework/Versions/3.10/bin/usbrply

import binascii
import time
import usb1
import time


def validate_read(expected, actual, msg):
    if expected != actual:
        print('Failed %s' % msg)
        print('  Expected; %s' % binascii.hexlify(expected,))
        print('  Actual:   %s' % binascii.hexlify(actual,))
        #raise Exception("failed validate: %s" % msg)

def hex_string_to_formatted_binary_array(hex_string):
    return bytes.fromhex(hex_string)


def interruptRead(dev, endpoint, size, timeout=None):
    return dev.interruptRead(endpoint, size,
                timeout=(1000 if timeout is None else timeout))

def interruptWrite(dev, endpoint, data, timeout=None):
    print(data)
    dev.interruptWrite(endpoint, data, timeout=(1000 if timeout is
None else timeout))

def create_byte_array_for_rot(rotation):
  """
  Creates a byte array with the specified rotation.

  Args:
    rotation: The rotation value.

  Returns:
    A byte array.
  """
  low_byte = rotation & 0xFF
  high_byte = (rotation >> 8) & 0xFF
  return bytearray([0x6b, low_byte, high_byte, 0x0d, low_byte, high_byte, 0x00, 0x00])



def rotate_to_angle(dev, angle):


    # Generated by usbrply
    # Source: Windows pcap (USBPcap)
    # cmd: /Library/Frameworks/Python.framework/Versions/3.10/bin/usbrply

    # PCapGen device hi: selected device 2
    # Generated from packet 7/8

    iangle = int(angle * 29)


    interruptWrite(dev, 0x02, hex_string_to_formatted_binary_array("672474038fb02795"))
    result = interruptRead(dev, 0x81, 8)
    print(result.hex())
    rot_array = create_byte_array_for_rot(iangle)
    print(rot_array.hex())
    interruptWrite(dev, 0x02,rot_array)



    for i in range(30):
        interruptWrite(dev, 0x02, hex_string_to_formatted_binary_array("6875f90538db760b"))
        result = interruptRead(dev, 0x81, 8)
        print(result.hex())
        time.sleep(0.01)

def c2_byte(v):
    if (v < 0):
        return 0x80 - v
    return v


def create_byte_array_for_move(dx, dy):
  """
  Creates a byte array with the specified rotation.

  Args:
    rotation: The rotation value.

  Returns:
    A byte array.
  """
  return bytearray([0x32, c2_byte(dx), c2_byte(dy), 0x00, 0x81, 0x7a, 0x90, 0x90])




def move_ao(dev, dx, dy):
    mov_array = create_byte_array_for_move(dx, dy)
    print(mov_array.hex())
    interruptWrite(dev, 0x02,mov_array)



def build_motor_move_array(motor_idx, delta):
  return bytearray([0x61, c2_byte(delta), c2_byte(motor_idx), 0x00, 0xc7, 0xdd, 0x42, 0x1a])



def move_motors(dev, m1, m2, m3, m4):
    mov_1 = build_motor_move_array(0, m1)
    mov_2 = build_motor_move_array(1, m2)
    mov_3 = build_motor_move_array(2, m3)
    mov_4 = build_motor_move_array(3, m4)
    interruptWrite(dev, 0x02,mov_1)
    time.sleep(0.1)
    interruptWrite(dev, 0x02,mov_2)
    time.sleep(0.1)
    interruptWrite(dev, 0x02,mov_3)
    time.sleep(0.1)
    interruptWrite(dev, 0x02,mov_4)
    time.sleep(0.1)


def b_2_i(v):
    if (v > 128):
        return v - 256
    return v

def get_ao_pos(dev):
    
    interruptWrite(dev, 0x02, hex_string_to_formatted_binary_array("30000000c7dd421a"))
    interruptWrite(dev, 0x02, hex_string_to_formatted_binary_array("62000000c7dd421a"))
    interruptWrite(dev, 0x02, hex_string_to_formatted_binary_array("3916421ac7dd421a"))
    
    result = interruptRead(dev, 0x81, 8)
    print(b_2_i(result[0]), b_2_i(result[1]), b_2_i(result[2]), b_2_i(result[3]))


def open_dev(vid_want, pid_want, usbcontext=None):
    if usbcontext is None:
        usbcontext = usb1.USBContext()

    print("Scanning for devices...")
    for udev in usbcontext.getDeviceList(skip_on_error=True):
        vid = udev.getVendorID()
        pid = udev.getProductID()
        if (vid, pid) == (vid_want, pid_want):
            print("Found device")
            print("Bus %03i Device %03i: ID %04x:%04x" % (
                udev.getBusNumber(),
                udev.getDeviceAddress(),
                vid,
                pid))
            return udev.open()
    raise Exception("could not connect to AO unit")

def main():
    import argparse

    vid_want = 0x03EB
    pid_want = 0x2013

    usbcontext = usb1.USBContext()
    dev = open_dev(vid_want, pid_want, usbcontext)
    
    dev.resetDevice()
    #dev.detachKernelDriver(0)
    dev.claimInterface(0)
    #rotate_to_angle(dev, 90)

    get_ao_pos(dev)
    move_motors(dev, 0, 0, 6, 0)
    get_ao_pos(dev)



"""
    move_ao(dev, 120, 120)
    time.sleep(0.3)
    move_ao(dev, 120, 120)
    time.sleep(0.3)
    move_ao(dev, -127, -127)
    time.sleep(0.3)
    for i in range(200):
        #move_ao(dev, 32, 0)
        time.sleep(0.3)
        move_ao(dev, 0, 32)
        time.sleep(0.3)
        #move_ao(dev, -32, 0)
        time.sleep(0.3)
        move_ao(dev, -0, -32)

        get_ao_pos(dev)
"""

if __name__ == "__main__":
    main()